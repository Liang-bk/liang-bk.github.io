---
title: 'LeetCode 每日一题'
publishDate: '2025-09-26'
updatedDate: '2025-09-28'
description: 'LeetCode 每日一题题解'
tags:
  - leetcode
  - algorithm
language: '中文'
heroImage: { src: './leetcode.png', color: '#B4C6DA' }
---
## 1039. 多边形三角剖分的最低得分（2025.9.29）

[原题链接](https://leetcode.cn/problems/minimum-score-triangulation-of-polygon/?envType=daily-question&envId=2025-09-29)

该题的考点是区间动态规划，仍然从集合的角度来分析

1. 状态表示：dp[l, r]表示由边(l, l + 1)， (l + 1, l + 2)，...，(r - 1, r)，(r, l)组成的多边形被剖分成不同的三角形集合

2. 状态属性：集合中乘积和的最小值

3. 状态转移：

   - 首先考虑如何划分集合：

     由于多边形最后最划分为多个三角形，那么多边形的边都是各个三角形的边，我们以(r, l)这条边隶属于哪个三角形来划分集合：

     (r, l)的两个端点l, r, 只需要再加一个端点就可以组成三角形，设端点为k，则**k = l + 1, ... r - 1**

   ​      于是由k和边(r, l)组成的三角形将原多边形划分为了三个部分：

            1. [l, k]：以(l, l + 1),...,(k, l)边组成的新多边形
            2. [k, r]：以(k, k + 1),...,(r, k)边组成的新多边形
            3. k&(r, l)：以点k和边(r, l)组成的三角形

   

   - 于是状态转移公式：

   $$
   dp[l, r] = min(dp[l, k] + dp[k, r] + v[l] * v[r] * v[k])
   $$

   

为什么选择(r, l)边作为三角形的一个边处理？

因为状态表示中无法直接涉及到(r, l)，而直接使用(r, l)边的三角形又能够将集合划分为不同的部分来完成状态的转移

code：

```c++
class Solution {
public:
    int minScoreTriangulation(vector<int>& values) {
        constexpr int N = 50;
        constexpr int INF = 0x3f3f3f3f;
        vector<vector<int>> dp(N, vector<int>(N, INF));
        int n = values.size();
        for (int i = 0; i < n; i++) {
            dp[i][i] = 0;
            if (i + 1 < n) {
                dp[i][i + 1] = 0;
            }
        }
        for (int len = 2; len < n; len++) {
            for (int l = 0; l < n; l++) {
                int r = l + len;
                if (r >= n) continue;
                // k: l + 1 -> r - 1
                for (int k = l + 1; k < r; k++) {
                    dp[l][r] = min(dp[l][r], 
                        dp[l][k] + dp[k][r] + values[l] * values[k] * values[r]);
                }
            }
        }
        return dp[0][n - 1];
    }
};
```

时间复杂度：$O(n^3)$
## 2040. 两个有序数组的第K小乘积（2025.9.28）

[原题链接](https://leetcode.cn/problems/kth-smallest-product-of-two-sorted-arrays/description/?envType=daily-question&envId=2025-09-28)

直接枚举$n^2$显然是不现实的，注意到两个数组的乘积值域在$[-10^{10}, 10^{10}]$之间

因此可以考虑对答案进行二分：

对于一个数`mid`，设两个数组的乘积中小于`mid`的数有`cnt`个，那么：

1. `cnt < k`，则`mid`有可能是答案，提高答案的下界
2. `cnt >= k`，则`mid`不可能是答案，降低答案的上界

于是问题转化为如何求两个数组的乘积中小于`mid`的个数

### 二分

由`nums1 × nums2 < mid`（`nums1`不为0），得：

1. `nums2 < mid / nums1`（`nums1 > 0`）
2. `nums2 > mid / nums1`（`nums1 < 0`）

两个数组都是排好序的，所以在遍历第一个数组的时候，利用二分求出小于/大于目标数的数字有多少个即可

code:

```c++
class Solution {
public:
    using i64 = long long;
    bool check(vector<int>& nums1, vector<int> &nums2, i64 k, i64 num) {
        // 找nums1 * nums2中，< num的个数cnt，与k比较
        // cnt < k -> true
        // cnt >= k -> false
        i64 cnt = 0;
        for (int n1 : nums1) {
            if (n1 == 0) {
                if (num > 0) cnt += nums2.size();
                continue;
            } 
            i64 n2 = num / n1;
            auto up_it = upper_bound(nums2.begin(), nums2.end(), n2);
            auto low_it = lower_bound(nums2.begin(), nums2.end(), n2);
            if (n1 > 0) {
                int d1 = distance(nums2.begin(), low_it);
                int d2 = distance(nums2.begin(), up_it);
                if (num > 0 && num % n1 != 0) {
                    cnt += max(0, d2);
                } else {
                    cnt += max(0, d1);
                }
            } else {
                int d1 = distance(low_it, nums2.end());
                int d2 = distance(up_it, nums2.end());
                if (num > 0 && num % n1 != 0) {
                    cnt += max(0, d1);
                } else {
                    cnt += max(0, d2);
                }
            }
        }
        return cnt < k;
    }
    long long kthSmallestProduct(vector<int>& nums1, vector<int>& nums2, long long k) {
        i64 low = min({1ll * nums1.front() * nums2.front(), 1ll * nums1.front() * nums2.back(),
                                1ll * nums1.back() * nums2.front(), 1ll * nums1.back() * nums2.back()});
        i64 high = max({1ll * nums1.front() * nums2.front(), 1ll * nums1.front() * nums2.back(),
                                1ll * nums1.back() * nums2.front(), 1ll * nums1.back() * nums2.back()});
        i64 ans = 0;
        while (low <= high) {
            i64 mid = (low + high) >> 1;
            if (check(nums1, nums2, k, mid)) {
                low = mid + 1;
                ans = mid;
            } else {
                high = mid - 1;
            }
        }
        return ans;
    }
};
```

时间复杂度：$O(n (logn)(logk))$

### 矩阵

数组单增，负数正数同时存在，我们可以将分界线列出，假设：

1. `nums1[0~pos1]`是负数，`nums1[pos1~n1]`是正数
2. `nums2[0~pos2]`是负数，`nums1[pos1~n2]`是正数

将`nums1[0~pos1]`与`nums2[0~pos2]`各个数分别相乘，观察性质(以两个数组中元素都大于0为例)：

![image-20250929174608939](./2040_1.png)

不难发现，左上角是最小值，随行增加，随列增加，右下角为最大值，之后求该矩阵中小于`mid`的个数，参考[leetcode-240](https://leetcode.cn/problems/search-a-2d-matrix-ii/description/?envType=study-plan-v2&envId=top-100-liked)

具体做法是利用双指针，指向矩阵右上角的坐标，计算矩阵中对应的位置元素，如果该元素大于等于`mid`，向左移动，否则向下移动，直到找到最后一个小于`mid`的元素，移动的过程中，每找到一个小于`mid`的元素，就累加该行的个数

code：

```c++
class Solution {
public:
    using i64 = long long;
    bool check(vector<int>& nums1, vector<int> &nums2, i64 k, i64 num) {
        // 找nums1 * nums2中，< num的个数cnt，与k比较
        // cnt < k -> true
        // cnt >= k -> false
        i64 cnt = 0;
        for (int i = 0, j = pos2; i <= pos1 && j >= 0;) {
            if (1ll * nums1[i] * nums2[j] >= num) {
                i++;
            }
            else {
                cnt += (pos1 - i + 1);
                j--;
            }
        }
        for (int i = 0, j = pos2 + 1; i <= pos1 && j < nums2.size();) {
            if (1ll * nums1[i] * nums2[j] >= num) {
                j++;
            } else {
                cnt += (nums2.size() - j);
                i++;
            }
        }
        for (int i = pos1 + 1, j = 0; i < nums1.size() && j <= pos2;) {
            if (1ll * nums1[i] * nums2[j] >= num) {
                i++;
            } else {
                cnt += (nums1.size() - i);
                j++;
            }
        }
        for (int i = pos1 + 1, j = nums2.size() - 1; i < nums1.size() && j > pos2;) {
            if (1ll * nums1[i] * nums2[j] >= num) {
                j--;
            } else {
                cnt += (j - pos2);
                i++;
            }
        }
        return cnt < k;
    }
    long long kthSmallestProduct(vector<int>& nums1, vector<int>& nums2, long long k) {
        i64 low = min({1ll * nums1.front() * nums2.front(), 1ll * nums1.front() * nums2.back(),
                                1ll * nums1.back() * nums2.front(), 1ll * nums1.back() * nums2.back()});
        i64 high = max({1ll * nums1.front() * nums2.front(), 1ll * nums1.front() * nums2.back(),
                                1ll * nums1.back() * nums2.front(), 1ll * nums1.back() * nums2.back()});
        i64 ans = 0;
        for (int i = 0; i < nums1.size(); i++) {
            if (nums1[i] < 0) pos1 = i;            
        }
        for (int i = 0; i < nums2.size(); i++) {
            if (nums2[i] < 0) pos2 = i;            
        }
        while (low <= high) {
            i64 mid = (low + high) >> 1;
            if (check(nums1, nums2, k, mid)) {
                low = mid + 1;
                ans = mid;
            } else {
                high = mid - 1;
            }
        }
        return ans;
    }
private:
    int pos1{-1};
    int pos2{-1};
};
```

时间复杂度：$O(nlogk)$

## 976. 三角形的最大周长（2025.9.28）

[原题链接](https://leetcode.cn/problems/largest-perimeter-triangle/description/?envType=daily-question&envId=2025-09-28)

枚举三条边a，b，c，三角形三边需要满足：
1. a + b > c
2. a + c > b
3. b + c > a

如果按边大小排序，设c >= b >= a，能简化为一个条件：
1. a + b > c

将边从大到小排序，在枚举一个最长边nums[i] = c时，能使得三角形周长最大的合法集合只能为nums[i], nums[i + 1], nums[i + 2]

1. 如果nums[i], nums[i + 1], nums[i + 2]合法，则三条边组成的三角形周长最大
2. 如果不合法，那么以nums[i] = c作为最长边将不能和nums[i + 3]及之后的边组成三角形

code: 
```c++
class Solution {
public:
    int largestPerimeter(vector<int>& nums) {
        sort(nums.begin(), nums.end(), greater<>());
        int ans = 0;
        for (int i = 2; i < nums.size(); i++) {
            // a <= b <= c
            int a = nums[i], b = nums[i - 1], c = nums[i - 2];
            if (c < a + b) {
                ans = a + b + c;
                break;
            }
        }
        return ans;
    }
};
```
时间复杂度： $O(n)$

## 812. 最大三角形面积（2025.9.27）

[原题链接](https://leetcode.cn/problems/largest-triangle-area/description/?envType=daily-question&envId=2025-09-27)

枚举三个点A，B，C，设三条边的边长为a，b，c

根据海伦公式（或者用余弦定理）得出：

$S = \sqrt {p (p - a) (p - b) (p - c)}$

其中，$p = \frac {a + b + c} {2}$

注意，如果三个点x坐标或y坐标相同，三角形不合法

code:

```c++
class Solution {
public:
    double getDistance(int x1, int y1, int x2, int y2) {
        double d2 = pow(x1 - x2, 2) + pow(y1 - y2, 2);
        return sqrt(d2);
    }
    double largestTriangleArea(vector<vector<int>>& points) {
        int n = points.size();
        double ans = INT_MIN;
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                for (int k = j + 1; k < n; k++) {
                    auto &pi = points[i];
                    auto &pj = points[j];
                    auto &pk = points[k];
                    if (pi[0] == pj[0] && pi[0] == pk[0]) continue;
                    if (pi[1] == pj[1] && pi[1] == pk[1]) continue;
                    double a = getDistance(pi[0], pi[1], pj[0], pj[1]);
                    double b = getDistance(pi[0], pi[1], pk[0], pk[1]);
                    double c = getDistance(pj[0], pj[1], pk[0], pk[1]);
                    double sum = (a + b + c) / 2;
                    ans = max(ans, sqrt(sum * (sum - a) * (sum - b) * (sum - c)));
                }
            }
        }
        return ans;
    }
};
```
时间复杂度： $O(n^3)$

## 611. 有效三角形的个数（2025.9.26）
[原题链接](https://leetcode.cn/problems/valid-triangle-number/description/?envType=daily-question&envId=2025-09-26)
### 排序 + 二分
将边长度按从小到大排序

因为需要三条边，无论如何都要枚举两条边a，b，不妨从小到大进行枚举（即`a <= b`）

设第三条边为c，那么c需要满足：
1. `a + b > c`
2. `a + c > b`
3. `b + c > a`

在枚举c的过程中，为了避免重复，c必须满足`c >= b`

故上述条件简化为：
1. `a <= b <= c`
2. `a + b > c`

设a，b对应的下标分别为i，j，那么c的下标范围是：

`[l, r] = [j + 1, lower_bound(nums.begin() + j + 1, nums.end(), a + b)]`
，如果`r < l`，则没有与a，b对应的c存在
code：
```c++
class Solution {
public:
    int triangleNumber(vector<int>& nums) {
        // 枚举a, b
        // c: a + b > c, a + c > b, b + c > a
        // -> c < a + b && c > b - a && c > a - b
        sort(nums.begin(), nums.end());
        int ans = 0;
        for (int i = 0; i < nums.size(); i++) {
            for (int j = i + 1; j < nums.size(); j++) {
                int k = j + 1;
                int start = max(nums[j] - nums[i], nums[i] - nums[j]);
                int end = nums[i] + nums[j];
                auto l = upper_bound(nums.begin() + k, nums.end(), start);
                auto r = lower_bound(nums.begin() + k, nums.end(), end);
                if (r - l < 0) continue;
                ans += (r - l);
            }
        }
        if (ans < 0) ans = 0;
        return ans;
    }
};
```
时间复杂度: $O(n^2logn)$
### 排序 + 双指针
二分的代码不难发现一个规律：枚举a，b后，寻找c时，只需要找到满足`c < a + b`的最大的c

换句话说，对于前一个b，有`c < a + b`，对于下一个b，也有可能有`c < a + b`

因此，我们只需要维护c所在区间的最大值下标

条件是：只要`c < a + b`，就让c的下标右移

c所在区间的最小值下标一定是b的下标+1

于是可以采用双指针，在枚举b的同时，维护c当前可能的最大值下标

code:
```c++
class Solution {
public:
    int triangleNumber(vector<int>& nums) {
        // 枚举a, b
        // c: a + b > c
        // a <= b <= c
        sort(nums.begin(), nums.end());
        int ans = 0;
        for (int i = 0; i < nums.size(); i++) {
            for (int j = i + 1, k = j + 1; j < nums.size(); j++) {
                // k是c合法范围内的最大值下标
                k = max(k, j + 1);
                int end = nums[i] + nums[j];
                while (k < nums.size() && nums[k] < end) {
                    k++;
                }
                ans += max(0, k - j - 1);
            }
        }
        return ans;
    }
};
```
时间复杂度：$O(n^2)$

## 120. 三角形最小路径和（2025.9.25）

[原题链接](https://leetcode.cn/problems/triangle/description/?envType=daily-question&envId=2025-09-25)

三角形dp，从集合的角度分析：

1. 状态表示：dp(i, j)：从triangle(0, 0)走到(i, j)的不同路径组成的集合

2. 状态计算：集合中路径总和的最小值

3. 状态转移：根据路径中的最后一次转移来划分集合

   - 从(i - 1, j)走到(i, j)

   - 从(i - 1, j - 1)走到(i, j)

   - 转移公式：
     $$
     dp(i, j) =
     \begin{cases}
     triangle(i, j), & i = 0, j = 0 \\
     dp(i - 1, j) + triangle(i, j), & i > 0, j = 0 \\
     min(dp(i - 1, j), dp(i - 1, j - 1)) + triangle(i, j) & i > 0, j > 0 \\
     \end{cases}
     $$

4. 优化：注意到在计算dp(i, ...)时，只需要dp(i - 1, ...)，所以可以将状态优化为1维数组，在计算状态时只保留上一层的状态dp(j)

code:

```c++
class Solution {
public:
    int minimumTotal(vector<vector<int>>& triangle) {
        int ans = INT_MAX;
        vector<int> dp(triangle.size(), INT_MAX / 2);
        dp[0] = triangle[0][0];
        for (int i = 1; i < triangle.size(); i++) {
            for (int j = triangle[i].size() - 1; j >= 0; j--) {
                int old_dp = INT_MAX / 2;
                if (j >= 1) old_dp = dp[j - 1];
                dp[j] = min(dp[j], old_dp) + triangle[i][j];
            }
        }
        for (int i = 0; i < dp.size(); i++) {
            ans = min(ans, dp[i]);
        }
        return ans;
    }
};
```
时间复杂度： $O(n^2)$
## 166. 分数到小数（2025.9.24）

[原题链接](https://leetcode.cn/problems/fraction-to-recurring-decimal/description/?envType=daily-question&envId=2025-09-24)

问题的难度在于如何判定循环小数的范围

使用长除法观察示例$\frac {4} {333} = 0.\dot 0 \dot 1 \dot 2$：

![166_1](./166_1.png)

1. 小数点后第1位为0时，对应的被除数为40
2. 小数点后第2位为1时，对应的被除数为400
3. 小数点后第3位为2时，对应的被除数为670

以此类推...， 小数点后第4位开始循环，对应的被除数为40

不难发现，当小数点后开始循环时，对应的被除数一定已经出现过，可以使用哈希表来保存出现过的被除数，当一个被除数重复出现时，说明有循环小数并已经开始循环

于是问题来到了如何判断哪一部分是循环小数，我们可以通过存储下面两个信息来解决：

1. **小数点后第k位对应的被除数**
2. **小数点后当前的总位数n**

当被除数重复时，小数点后**第k位~第n位**就是循环小数所在的部分，前者可以用hashmap解决，后者可以开辟一个额外变量来记录

由于题目中分子，分母的范围在[INT_MIN, INT_MAX]，所以在计算时最好使用long long，同时将小数点前和小数点后的计算分开，更加清晰

code:

```c++
class Solution {
public:
    using i64 = long long;
    void transform_quotient(string &ans, i64 quotient) {
        string res("");
        while (quotient > 0) {
            int mod = quotient % 10;
            quotient /= 10;
            res += static_cast<char>(mod + '0');
        }
        if (res.size() == 0) return;
        for (int i = res.size() - 1; i >= 0; i--) {
            ans += res[i];
        }
    }
    string fractionToDecimal(int numerator, int denominator) {
        bool neg1 = numerator < 0;
        bool neg2 = denominator < 0;
        i64 numerator1 = abs(numerator * 1ll);
        i64 denominator1 = abs(denominator * 1ll);
        string ans("");
        // 小数点前
        if (numerator1 >= denominator1) {
            while (numerator1 >= denominator1) {
                i64 quotient = numerator1 / denominator1;
                numerator1 %= denominator1;
                transform_quotient(ans, quotient);
            }
        } else {
            ans += '0';
        }
        // 小数点后
        if (numerator1 != 0){
            ans += '.';
            int index = ans.size();
            vector<int> cycle;
            unordered_map<int, int> hash;
            while (true) {
                numerator1 *= 10;
                if (hash.contains(numerator1)) {
                    int st = hash[numerator1];
                    string tmp = ans.substr(0, cycle[st]) + '(';
                    for (int i = cycle[st]; i < ans.size(); i++) {
                        tmp += ans[i];
                    }
                    tmp += ')';
                    ans = tmp;
                    break;
                }
                int quotient = numerator1 / denominator1;
                cycle.push_back(index);
                hash[numerator1] = cycle.size() - 1;
                index++;
                numerator1 %= denominator1;
                ans += static_cast<char>(quotient + '0');
                if (numerator1 == 0) {
                    break;
                }
            }
        }
        if (neg1 != neg2 && numerator != 0) {
            ans = "-" + ans;        
        }
        return ans;
    }
};
```
时间复杂度：设小数点后位数数量级为n，代码时间复杂度为$O(n)$
